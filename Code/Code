# UFC Project by Victor King - Syracuse Grad Sport Analytics 


# Section 1 Loading the libraries

library(ggplot2)    # For data visualization, creating plots such as histograms, scatter plots, and boxplots
library(readr)      # For reading data from CSV files and other text files
library(dplyr)      # For data manipulation, including filtering, selecting, and summarizing data
library(car)        # For statistical analysis, including functions like ANOVA and VIF
library(purrr)      # For functional programming, working with lists, and applying functions
library(reshape2)   # For reshaping data, especially converting data between wide and long formats
library(multcomp)   # For multiple comparison procedures, useful in post-hoc testing
library(pROC)       # For plotting ROC curves and calculating AUC for binary classifiers
library(caret)      # For model training, cross-validation, and creating confusion matrices
library(iml)        # For interpretable machine learning, including SHAP value calculation
library(mlr)        # For creating and tuning machine learning models
library(ranger)     # For fast implementation of Random Forests, a classification model
library(xgboost)    # For gradient boosting, a powerful ensemble learning technique
library(e1071)      # For support vector machines (SVMs), and other functions like tuning models
library(tidyr)      # For data tidying, including functions like pivot_longer() and pivot_wider()
library(viridis)    # For colorblind-friendly color palettes, often used in ggplot2
library(GGally)     # For creating advanced plots, including pairs plots (scatterplot matrices)
library(RColorBrewer)  # For color palettes, especially sequential, diverging, and qualitative palettes
library(ggridges)   # For creating ridge plots (joy plots), a visualization of distributions
library(treemap)    # For creating treemaps, which display hierarchical data as nested rectangles
library(fmsb)       # For creating radar charts, useful for comparing multivariate data
library(networkD3)  # For creating interactive network visualizations using D3.js
library(vcd)        # For visualizing categorical data, including mosaic plots and association plots
library(igraph)     # For creating and analyzing network graphs
library(lubridate)  # For working with date and time data, simplifying date manipulations
library(rpart)      # For creating decision trees, a method of classification and regression
library(rpart.plot) # For visualizing decision trees created with rpart
library(ggtern)     # For creating ternary plots using ggplot2, useful for three-component data


# --------------------------------------------------------


# Section 2 Loading and Organizing the CSV

# Loading and Organizing the dataset prior to beginning the Summary Statistics and EDA

historical_data <- read.csv("historical_data.csv")
old_data <- read.csv("historical_data_corrected_dates.csv")  # Older version with correct Date and Birthdate

# Replace Date and Birthdate columns in the current dataset with those from the older dataset
historical_data$Date <- old_data$Date
historical_data$Birthdate <- old_data$Birthdate


historical_data$Date <- as.Date(historical_data$Date, format = "%m/%d/%Y")
historical_data$Birthdate <- as.Date(historical_data$Birthdate, format = "%m/%d/%Y")

write.csv(historical_data, "historical_data.csv", row.names = FALSE)

# Reason we load the old_data is that this is before we feature engineered the csv and the data and birthday column are properly working

# ----------------------------- 


# Section 3 Creating Aggregated Data

# Identify all numeric and integer columns
numeric_columns <- names(historical_data)[sapply(historical_data, is.numeric) | sapply(historical_data, is.integer)]

# Create a summary dataset by aggregating data per fighter and stance for all numeric/integer columns
aggregated_fighter_data <- historical_data %>%
  group_by(Fighter, Stance, WT_Class, Date, Birthdate) %>%
  summarize(across(all_of(numeric_columns), 
                   list(mean = ~mean(.x, na.rm = TRUE), 
                        sum = ~sum(.x, na.rm = TRUE), 
                        max = ~max(.x, na.rm = TRUE),
                        min = ~min(.x, na.rm = TRUE),
                        sd = ~sd(.x, na.rm = TRUE))), 
            .groups = 'drop') %>%  # Ungroup after summarization
  mutate(across(everything(), ~replace_na(.x, 0)))  # Replace NA values with 0

# first few rows of the aggregated data
head(aggregated_fighter_data)

# Save to a CSV
write.csv(aggregated_fighter_data, "aggregated_fighter_data.csv", row.names = FALSE)


# Aggregating by Fighter, Stance, WT_Class, Date, and Birthdate


# - Fighter: Each row in the aggregated dataset will correspond to a unique fighter.
# - Stance: Since a fighter might switch stances across different fights, aggregating by stance
#   helps capture the performance metrics associated with each stance.
# - WT_Class: Fighters often compete in different weight classes throughout their careers.
#   Aggregating by weight class ensures that the analysis accounts for performance in each class.
# - Date: Including the date helps in tracking the progression of a fighter's performance over time.
# - Birthdate: This allows us to keep track of the fighter's age during each fight, which might
#   be relevant for certain analyses, such as evaluating age-related performance trends.


# -------------------------------------------               




# Section 4 Summary Statistics


# Check the structure of the dataset
str(historical_data)

# Summary statistics for key numeric variables (Mean, Median, Mode, Variance)
summary(historical_data)

# Calculate median values for key numeric variables
median_values <- historical_data %>%
  summarise(across(where(is.numeric), \(x) median(x, na.rm = TRUE)))

# Calculate mode values for key numeric variables
mode_values <- historical_data %>%
  summarise(across(where(is.numeric), ~as.numeric(names(sort(table(.), decreasing = TRUE)[1]))))

# Calculate variance for key numeric variables
variance_values <- historical_data %>%
  summarise(across(where(is.numeric), \(x) var(x, na.rm = TRUE)))

# Display the calculated median, mode, and variance
print("Median Values:")
print(median_values)

print("Mode Values:")
print(mode_values)

print("Variance Values:")
print(variance_values)

# Count the number of unique fighters
num_fighters <- historical_data %>% distinct(Fighter) %>% nrow()

# Count the number of unique countries
num_countries <- historical_data %>% distinct(Country) %>% nrow()

# Get the distribution of fighters by country
fighters_by_country <- historical_data %>%
  group_by(Country) %>%
  summarise(Num_Fighters = n_distinct(Fighter)) %>%
  arrange(desc(Num_Fighters))

# Analyze the time frame of fights
time_frame <- range(historical_data$Date, na.rm = TRUE)

# results
list(
  Number_of_Fighters = num_fighters,
  Number_of_Countries = num_countries,
  Fighters_by_Country = fighters_by_country,
  Time_Frame = time_frame
)

# Frequency counts for key categorical columns I picked
frequency_counts_results <- table(historical_data$Res)
frequency_counts_team <- table(historical_data$Team)
frequency_counts_continent <- table(historical_data$Continent)
frequency_counts_country <- table(historical_data$Country)
frequency_counts_wt_class <- table(historical_data$WT_Class)
frequency_counts_stance <- table(historical_data$Stance)
frequency_counts_decision <- table(historical_data$Decision)


# Display frequency counts
print("Frequency Counts for Results:")
print(frequency_counts_results)

print("Frequency Counts for Team:")
print(frequency_counts_team)

print("Frequency Counts for Continent:")
print(frequency_counts_continent)

print("Frequency Counts for Country:")
print(frequency_counts_country)

print("Frequency Counts for WT_Class:")
print(frequency_counts_wt_class)

print("Frequency Counts for Stance:")
print(frequency_counts_stance)

print("Frequency Counts for Decision:")
print(frequency_counts_decision)


# Correlation matrix for numeric variables
correlation_matrix <- cor(historical_data[sapply(historical_data, is.numeric)])

# View the correlation matrix
print("Correlation Matrix:")
print(correlation_matrix)


# --------------------------------------------------




# Section 5 EDA


# Histograms
# --- Distribution of Fighter Heights: Unique Instances Only ---

# Ensure each fighter is represented only once
unique_fighters_data <- historical_data %>%
  distinct(Fighter, .keep_all = TRUE)

# Histogram for Fighter Height (Unique Instances)
ggplot(unique_fighters_data, aes(x = Height)) +
  geom_histogram(binwidth = 1, fill = "lightblue", color = "black") +
  labs(title = "Distribution of Fighter Heights (Unique Instances)", 
       x = "Height (inches)", 
       y = "Frequency") +
  theme_minimal()

# Save the plot
ggsave("fighter_height_distribution_unique.pdf", width = 10, height = 6)




# Pie Charts
# --- Distribution of Fighter Stances: Unique Instances Only ---

# Ensure each fighter is represented once
unique_fighters_data <- historical_data %>%
  distinct(Fighter, .keep_all = TRUE)  # Keep only the first occurrence of each fighter

# Count the number of fighters for each stance
stance_distribution <- unique_fighters_data %>%
  count(Stance)

# Create the pie chart
pie_chart <- ggplot(stance_distribution, aes(x = "", y = n, fill = Stance)) +
  geom_bar(stat = "identity", width = 1) +
  coord_polar("y") +
  labs(title = "Distribution of Fighter Stances (Unique Instances)", 
       fill = "Stance") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3")

# Save the pie chart
ggsave("fighter_stance_distribution_pie_chart.pdf", plot = pie_chart, width = 8, height = 6)

# Print the pie chart
print(pie_chart)




#Line Graph 
# --- Trends in Average Fight Duration Over Time by Female Weight Class (With Smoothed Lines) ---

# Standardize weight class names
historical_data <- historical_data %>%
  mutate(WT_Class = case_when(
    WT_Class %in% c("Women's Featherweight", "Featherweight") ~ "Women's Featherweight",
    WT_Class %in% c("Women's Bantamweight", "Bantamweight") ~ "Women's Bantamweight",
    WT_Class %in% c("Women's Flyweight", "Flyweight") ~ "Women's Flyweight",
    WT_Class == "Strawweight" ~ "Women's Strawweight",
    WT_Class %in% c("Welterweight", "Lightweight", "Heavyweight", "Middleweight", "Light Heavyweight") ~ WT_Class,
    TRUE ~ "Other"  # Optionally categorize any unexpected values
  ))

# Confirm the changes
unique(historical_data$WT_Class)

# Define female weight classes
female_classes <- c("Women's Strawweight", "Women's Flyweight", "Women's Bantamweight")

# Filter the aggregated data for these classes
female_data <- aggregated_fighter_data %>%
  filter(WT_Class %in% female_classes)

# Create the line plot with geom_smooth
female_fight_duration_plot <- ggplot(female_data, aes(x = Date, y = Time_Seconds_mean, color = WT_Class)) +
  geom_line(size = 1.2) +  # Thicker lines for better visibility
  geom_point(size = 2) +  # Add points for each data point
  geom_smooth(method = "loess", se = FALSE, linetype = "dashed", size = 1) +  # Add smoothed lines
  labs(title = "Average Fight Duration Over Time by Female Weight Class",
       x = "Date", y = "Average Fight Duration (seconds)", color = "Weight Class") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")  # Use a color palette with better contrast

# Print and save the plot
print(female_fight_duration_plot)
ggsave("female_fight_duration_over_time_with_smooth.pdf", plot = female_fight_duration_plot, width = 10, height = 8)






# Bar Graphs 
# --- Distribution by Method of Victory --- 


# Create a dataset with only unique fighters (remove duplicates)
unique_fighters_data <- historical_data %>%
  distinct(Fighter, .keep_all = TRUE)  # Keep only the first occurrence of each fighter

# Summarize the count for each method of victory
victory_method_counts <- unique_fighters_data %>%
  summarise(
    Decision_Unanimous = sum(Decision_Unanimous, na.rm = TRUE),
    Decision_Split = sum(Decision_Split, na.rm = TRUE),
    Decision_Majority = sum(Decision_Majority, na.rm = TRUE),
    KO_TKO = sum(KO_TKO, na.rm = TRUE),
    TKO_Doctors_Stoppage = sum(TKO_Doctors_Stoppage, na.rm = TRUE),
    Submission = sum(Submission, na.rm = TRUE),
    No_Contest = sum(No_Contest, na.rm = TRUE),
    Draw = sum(Draw, na.rm = TRUE)
  ) %>%
  pivot_longer(cols = everything(), names_to = "Method", values_to = "Count")

# Create a bar chart to show the distribution of different methods of victory
victory_distribution_plot <- ggplot(victory_method_counts, aes(x = Method, y = Count, fill = Method)) +
  geom_bar(stat = "identity") +
  labs(title = "Method of Victory Distribution Among Fighters",
       x = "Method of Victory",
       y = "Count") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Save the plot
ggsave("method_of_victory_distribution.pdf", plot = victory_distribution_plot, width = 10, height = 6)

# Display the plot
print(victory_distribution_plot)



#Box Plots
# --- Compare the duration of fights that ended in different outcomes (e.g., KO/TKO, Decision) --- 

# Ensure each fighter is represented once
unique_fighters_data <- historical_data %>%
  distinct(Fighter, .keep_all = TRUE)  # Keep only the first occurrence of each fighter

# Create the box plot
fight_duration_plot <- ggplot(unique_fighters_data, aes(x = factor(Decision), y = Time_Seconds, fill = factor(Decision))) +
  geom_boxplot() +
  labs(title = "Comparison of Fight Duration by Outcome (Unique Instances)", 
       x = "Outcome (Decision Type)", y = "Fight Duration (seconds)") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for readability

# Print and save the plot
print(fight_duration_plot)
ggsave("fight_duration_by_outcome_unique.pdf", plot = fight_duration_plot, width = 10, height = 8)



#Scatter Plots 
#  --- Scatter plot for Weight vs. Total Strikes Landed ---

# Ensure the data is aggregated per fighter with relevant metrics
aggregated_fighter_data <- historical_data %>%
  group_by(Fighter) %>%
  summarize(
    Weight = mean(Weight, na.rm = TRUE),
    TDL = sum(TDL, na.rm = TRUE),  # Total Takedowns Landed
    AD = sum(AD, na.rm = TRUE),    # Total Advances
    SM = sum(SM, na.rm = TRUE)     # Total Submission Attempts
  )

# Scatter plot for Weight vs. TDL
weight_vs_tdl_plot <- ggplot(aggregated_fighter_data, aes(x = Weight, y = TDL)) +
  geom_point(color = "blue", alpha = 0.6) +
  geom_smooth(method = "lm", color = "red", se = FALSE) +
  labs(title = "Weight vs. Takedown Landed (Aggregated Data)", 
       x = "Weight (lbs)", y = "Takedown Landed (TDL)") +
  theme_minimal()

# Print and save the plot
print(weight_vs_tdl_plot)
ggsave("weight_vs_takedown_landed_aggregated.pdf", plot = weight_vs_tdl_plot, width = 10, height = 8)


# Heatmap    
# --- Correlation Matrix of Key Performance Metrics ---

# Correlation matrix for numeric variables
correlation_matrix <- cor(historical_data[sapply(historical_data, is.numeric)])

# Melt the correlation matrix
melted_cor_matrix <- melt(correlation_matrix)

# Create the heatmap
ggplot(data = melted_cor_matrix, aes(x = Var1, y = Var2, fill = value)) + 
  geom_tile(color = "white") +
  scale_fill_gradient2(low = "blue", high = "red", mid = "white", 
                       midpoint = 0, limit = c(-1,1), space = "Lab", 
                       name = "Pearson\nCorrelation") +
  theme_minimal() + 
  theme(axis.text.x = element_text(angle = 45, vjust = 1, 
                                   size = 8, hjust = 1)) +
  coord_fixed() +
  labs(title = "Correlation Matrix Heatmap")

# Save the heatmap as PDF
ggsave("correlation_matrix_heatmap.pdf", width = 10, height = 10)


# Density
# --- Distribution of Fight Durations by Outcome: A Density Analysis ---

# Fight Duration by Outcome
ggplot(historical_data, aes(x = Total_Fight_Time_Seconds, fill = factor(Decision))) +
  geom_density(alpha = 0.5) +
  labs(title = "Density Plot of Fight Duration by Outcome",
       x = "Fight Duration (seconds)",
       y = "Density",
       fill = "Outcome") +
  theme_minimal()

# Save the plot
ggsave("fight_duration_by_outcome_density.pdf", width = 10, height = 6)


#Pair plots 
# --- Comprehensive Pair Plot of Fighter Performance Metrics: Wins vs. Losses ---

# Reset any previous graphics device
dev.off()  # Clear any previous graphics settings

# Select the relevant columns for the pair plot
pair_plot_data <- dplyr::select(historical_data, AD, ADTB, ADHG, ADTM, ADTS, SM, RV, SR, Results)

# Adjust the margins before plotting
par(mar = c(0.5, 0.5, 0.5, 0.5))  # smaller margins

# Generate the pair plot with additional adjustments
pairs(pair_plot_data[, -ncol(pair_plot_data)],  # Exclude the Results column from the pairs plot
      main = "Pair Plot of Selected Fighter Performance Metrics",
      pch = 21, 
      bg = c("red", "green")[as.factor(pair_plot_data$Results)],  # Use Results column for colors
      cex.labels = 0.5,  # Smaller label size
      cex = 0.4,  # Smaller point size
      cex.main = 0.8,  # Smaller main title
      cex.axis = 0.6,  # Smaller axis text
      cex.lab = 0.6)   # Smaller axis labels

# Reset margins to default after plotting
par(mar = c(5, 4, 4, 2) + 0.1)


# Violin Plots
# --- Violin Plot for Average Fight Duration by Weight Class (Aggregated Data) ---

# Use the aggregated data to calculate the average fight duration per fighter
aggregated_fighter_data <- historical_data %>%
  group_by(Fighter, WT_Class) %>%
  summarize(Time_Seconds_mean = mean(Time_Seconds, na.rm = TRUE), .groups = 'drop')

# Create the violin plot
fight_duration_violin_plot <- ggplot(aggregated_fighter_data, aes(x = WT_Class, y = Time_Seconds_mean, fill = WT_Class)) +
  geom_violin(trim = FALSE) +
  labs(title = "Distribution of Average Fight Duration by Weight Class (Aggregated Data)",
       x = "Weight Class", y = "Average Fight Duration (seconds)") +
  theme_minimal() +
  scale_fill_brewer(palette = "Set3") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for readability

# Print and save the plot
print(fight_duration_violin_plot)
ggsave("fight_duration_by_weight_class_violin_aggregated.pdf", plot = fight_duration_violin_plot, width = 10, height = 8)



# Ridgeline Plots
# --- Distribution of Average Fight Duration by Stance (Aggregated Data) ---

# Create a summary dataset by aggregating data per fighter and stance for all numeric/integer columns
aggregated_fighter_data <- historical_data %>%
  group_by(Fighter, Stance, WT_Class, Date, Birthdate) %>%
  summarize(across(all_of(numeric_columns), 
                   list(mean = ~mean(.x, na.rm = TRUE), 
                        sum = ~sum(.x, na.rm = TRUE), 
                        max = ~max(.x, na.rm = TRUE),
                        min = ~min(.x, na.rm = TRUE),
                        sd = ~sd(.x, na.rm = TRUE))), 
            .groups = 'drop') %>%  # Ungroup after summarization
  mutate(across(everything(), ~replace_na(.x, 0)))  # Replace NA values with 0


# Create a ridgeline plot for Average Fight Duration by Stance
ridgeline_plot_stances <- ggplot(aggregated_fighter_data, aes(x = Time_Seconds_mean, y = Stance, fill = Stance)) +
  geom_density_ridges(alpha = 0.7, scale = 3) +  # Adjust alpha for transparency and scale for height of ridges
  labs(title = "Distribution of Average Fight Duration by Stance (Aggregated Data)", 
       x = "Average Fight Duration (seconds)", 
       y = "Stance") +
  theme_minimal() +
  theme(legend.position = "none") +  # Hide the legend if not needed
  scale_fill_viridis_d(option = "C")  # Use a color palette with better contrast

# Print and save the plot
print(ridgeline_plot_stances)
ggsave("ridgeline_plot_fight_duration_by_stance.pdf", plot = ridgeline_plot_stances, width = 10, height = 8)


#  Facet Grids/Wraps
# --- Density Plot of Fight Duration by Outcome Across Weight Classes ---

ggplot(historical_data, aes(x = Total_Fight_Time_Seconds, fill = factor(Decision))) +
  geom_density(alpha = 0.5) +
  labs(title = "Density Plot of Fight Duration by Outcome Across Weight Classes") +
  theme_minimal() +
  facet_wrap(~WT_Class)


# Bubble Charts:
# --- Bubble Chart: Clinch Head Strikes vs. X.HEAD ---

ggplot(unique_fighters_data, aes(x = X.Clinch_Head_Strikes, y = X.HEAD, size = KD )) +
  geom_point(alpha = 0.6, color = "orange") +
  labs(title = "Bubble Chart: Clinch Head Strikes vs. X.HEAD", 
       x = "Clinch Head Strikes", 
       y = "Ground Head Strikes", 
       size = "Knockdowns (KD)") +
  theme_minimal()





# Treemap
# --- Treemap of UFC Fighters by Continent and Country (Unique Instances) ---

treemap_data <- unique_fighters_data %>%
  group_by(Continent, Country) %>%
  summarise(Count = n(), .groups = 'drop')


treemap(treemap_data,
        index = c("Continent", "Country"),
        vSize = "Count",
        vColor = "Count",
        type = "value",
        title = "Treemap of Fighters by Continent and Country",
        palette = "Set3")


colnames(historical_data)


# Radar Chart
# --- Radar Chart: Fighter Performance Metrics ---

# Select the relevant columns for the radar chart
radar_data <- historical_data %>%
  dplyr::select(X.Clinch_Body_Strikes, X.Clinch_Head_Strikes, X.Clinch_Leg_Strikes, 
                X.Ground_Body_Strikes, X.Ground_Head_Strikes, X.Ground_Leg_Strikes, 
                X.Significant_Strikes, X.Total_Strikes, X.TK_ACC, 
                X.BODY, X.HEAD, X.LEG) %>%
  head(5)  # Selecting the first 5 fighters for simplicity

# Preparing the data for the radar chart
# Normalizing data to ensure that it fits the radar chart
max_vals <- apply(radar_data, 2, max, na.rm = TRUE)
min_vals <- apply(radar_data, 2, min, na.rm = TRUE)

# Adding the min and max values as the first two rows of the data
radar_data <- rbind(max_vals, min_vals, radar_data)

# Creating the radar chart
radarchart(radar_data, axistype = 1,
           pcol = rainbow(nrow(radar_data) - 2), pfcol = alpha(rainbow(nrow(radar_data) - 2), 0.5),
           plwd = 2, cglcol = "grey", cglty = 1, axislabcol = "grey", caxislabels = seq(0, max(max_vals), length = 5),
           cglwd = 0.8, vlcex = 0.8)

# Add a title to the radar chart
title(main = "Radar Chart: Selected Fighter Performance Metrics")


# Lollipop Charts
# Number of Wins by Team (Teams with at Least 7 Wins)

# Summarize the number of wins for each team and filter for teams with 7 wins or more
wins_by_team <- historical_data %>%
  group_by(Team) %>%
  summarise(Wins = sum(Results == 1, na.rm = TRUE)) %>%
  filter(Wins >= 7) %>%  # Filter for teams with 7 wins or more
  arrange(desc(Wins))

# Create the lollipop chart
ggplot(wins_by_team, aes(x = reorder(Team, -Wins), y = Wins)) +
  geom_point(color = "red", size = 4) +
  geom_segment(aes(x = Team, xend = Team, y = 0, yend = Wins)) +
  labs(title = "Number of Wins by Team (Teams with at Least 7 Wins)", 
       x = "Team", y = "Number of Wins") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

# Save the plot
ggsave("wins_by_team_lollipop.pdf", width = 10, height = 6)


# Circular Barplots
# Circular Barplot for Number of Wins by Country

# Summarize the number of wins for each country and filter for countries with 5 wins or more
wins_by_country <- historical_data %>%
  group_by(Country) %>%
  summarise(Wins = sum(Results == 1)) %>%
  filter(Wins >= 5) %>%  # Filter for countries with 5 wins or more
  arrange(desc(Wins))

# Create the circular barplot
ggplot(wins_by_country, aes(x = reorder(Country, -Wins), y = Wins)) +
  geom_bar(stat = "identity", fill = "skyblue") +
  coord_polar(theta = "x") +
  labs(title = "Number of Wins by Country (Circular Barplot)", x = "", y = "Number of Wins") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))  # Rotate x-axis labels for better readability

# Save the plot
ggsave("wins_by_country_circular_barplot.pdf", width = 10, height = 8)



# Waterfall Chart
# --- Fight Outcome Contributions: A Waterfall Chart ---

# Create a named vector for the waterfall chart
waterfall_data <- c(
  "Starting Point" = 0, 
  "KO_TKO" = 50, 
  "Submission" = 20, 
  "Decision" = -10, 
  "End Point" = 60
)

# Create the waterfall chart
waterfall(
  values = waterfall_data,
  labels = names(waterfall_data),  # Specify labels using the names of the vector
  rect_text_size = 3,
  fill_by_sign = TRUE
)

# Save the plot if needed
ggsave("waterfall_chart.pdf", width = 10, height = 6)



# Cleveland dot
# --- Average Fight Duration by Continent: A Cleveland Dot Plot ---

# Calculate the average fight duration per continent
avg_fight_duration_continent <- historical_data %>%
  group_by(Continent) %>%
  summarize(Average_Fight_Duration = mean(Time_Seconds, na.rm = TRUE))

# Create the Cleveland dot plot
cleveland_dot_plot <- ggplot(avg_fight_duration_continent, aes(x = Average_Fight_Duration, y = Continent)) +
  geom_point(color = "blue", size = 3) +
  labs(title = "Average Fight Duration by Continent", x = "Average Fight Duration (seconds)", y = "Continent") +
  theme_minimal()

# Print and save the plot
print(cleveland_dot_plot)
ggsave("avg_fight_duration_by_continent.pdf", plot = cleveland_dot_plot, width = 10, height = 8)





# Sankey diagram
# --- Sankey Diagram of Fight Outcomes by Continent ---

# Define the data for the Sankey diagram: Continent to Fight Outcome
sankey_data <- data.frame(
  source = c("Africa", "Africa", "Asia", "Asia", "Europe", "Europe", "North America", "North America", "Oceania", "Oceania", "South America", "South America"),
  target = c("KO/TKO", "Decision", "KO/TKO", "Decision", "KO/TKO", "Decision", "KO/TKO", "Decision", "KO/TKO", "Decision", "KO/TKO", "Decision"),
  value = c(5, 3, 7, 4, 12, 8, 18, 11, 3, 2, 4, 3)
)

# Convert source and target to factors and then to numeric indices
sankey_data$source <- as.numeric(factor(sankey_data$source)) - 1
sankey_data$target <- as.numeric(factor(sankey_data$target)) - 1

# Create a node data frame
nodes <- data.frame(name = unique(c("Africa", "Asia", "Europe", "North America", "Oceania", "South America", "KO/TKO", "Decision")))

# Create the Sankey diagram
sankeyNetwork(
  Links = sankey_data,
  Nodes = nodes,
  Source = "source",
  Target = "target",
  Value = "value",
  NodeID = "name",
  units = "fights",
  fontSize = 12,
  nodeWidth = 30
)




# Mosaic Plots:
# --- Mosaic Plot of Weight Class vs. Fight Decision ---
mosaic(~ WT_Class + Decision, data = historical_data, shade = TRUE, legend = TRUE)


# Cumulative Plot
# --- Cumulative Growth of Total Strikes in UFC Fights Over Time--- 
dev.off()  # Reset the graphics device

# Aggregate data by date to calculate cumulative total strikes
cumulative_data <- historical_data %>%
  group_by(Date) %>%
  summarize(Cumulative_Strikes = sum(X.Total_Strikes, na.rm = TRUE)) %>%
  arrange(Date) %>%
  mutate(Cumulative_Frequency = cumsum(Cumulative_Strikes))

# Create the cumulative frequency plot
cumulative_plot <- ggplot(cumulative_data, aes(x = Date, y = Cumulative_Frequency)) +
  geom_line(color = "blue", size = 1) +
  labs(title = "Cumulative Frequency of Total Strikes Over Time",
       x = "Date",
       y = "Cumulative Number of Strikes") +
  theme_minimal()

# Print the plot
print(cumulative_plot)

# Save the plot as a PDF
ggsave("cumulative_frequency_plot.pdf", plot = cumulative_plot, width = 10, height = 6)



# Ternary Plot 
# --- Ternary Plot of Fighter Strike Distribution: Body, Head, and Leg Strikes ---

# Aggregate data by fighter to calculate the average proportion of each strike type
ternary_data <- historical_data %>%
  group_by(Fighter) %>%
  summarize(
    Body_Strikes = sum(X.BODY, na.rm = TRUE),
    Head_Strikes = sum(X.HEAD, na.rm = TRUE),
    Leg_Strikes = sum(X.LEG, na.rm = TRUE)
  ) %>%
  mutate(Total_Strikes = Body_Strikes + Head_Strikes + Leg_Strikes) %>%
  filter(Total_Strikes > 0) %>%  # Filter out cases with zero total strikes
  mutate(
    Body_Prop = Body_Strikes / Total_Strikes,
    Head_Prop = Head_Strikes / Total_Strikes,
    Leg_Prop = Leg_Strikes / Total_Strikes
  )

# Create the ternary plot
ternary_plot <- ggtern(data = ternary_data, aes(x = Head_Prop, y = Body_Prop, z = Leg_Prop)) +
  geom_point(color = "blue", size = 3, alpha = 0.7) +
  labs(
    title = "Ternary Plot of Strike Proportions",
    x = "Proportion of Head Strikes",
    y = "Proportion of Body Strikes",
    z = "Proportion of Leg Strikes"
  ) +
  theme_minimal()

# Print the plot
print(ternary_plot)

# Save the plot as a PDF file
ggsave("ternary_plot_strike_proportions.pdf", plot = ternary_plot, width = 8, height = 8)








# --- Network Graph of Selected UFC Fights: Connections Between Fighters ---
# Network Graph

# Define the edges representing the updated list of fights between fighters
edges <- data.frame(
  from = c("Leon Edwards", "Khamzat Chimaev", "Tom Aspinall", "Arnold Allen", "Paddy Pimblett"),
  to = c("Belal Muhammad", "Gilbert Burns", "Curtis Blaydes", "Giga Chikadze", "Bobby Green")
)

# Create and Plot the Updated Graph

#  Create the graph object
g <- graph_from_data_frame(edges, directed = TRUE)

# Customize and plot the graph
plot(g, 
     vertex.color = "skyblue", 
     vertex.size = 20, 
     vertex.label.color = "black", 
     edge.arrow.size = 0.5, 
     main = "Network Graph of Selected UFC Fights")

#Save the Updated Graph as an Image
# Save the plot as a PNG
png("network_graph_selected_ufc_fights.png", width = 1000, height = 800)
plot(g, 
     vertex.color = "skyblue", 
     vertex.size = 20, 
     vertex.label.color = "black", 
     edge.arrow.size = 0.5, 
     main = "Network Graph of Selected UFC Fights")
dev.off()

# Save the plot as a PNG
png("network_graph_selected_ufc_fights.png", width = 1000, height = 800)
plot(g, 
     vertex.color = "skyblue", 
     vertex.size = 20, 
     vertex.label.color = "black", 
     edge.arrow.size = 0.5, 
     main = "Network Graph of Selected UFC Fights")
dev.off()




# --- Hierarchical Clustering of UFC Fighters by Continent Based on Physical Metrics --- 
# Dendrogram visualization 

# Ensure the Continent column is in the aggregated dataset
aggregated_fighter_data <- historical_data %>%
  group_by(Fighter, Stance, WT_Class, Date, Birthdate, Continent) %>%  # Ensure Continent is included
  summarize(across(all_of(numeric_columns), 
                   list(mean = ~mean(.x, na.rm = TRUE), 
                        sum = ~sum(.x, na.rm = TRUE), 
                        max = ~max(.x, na.rm = TRUE),
                        min = ~min(.x, na.rm = TRUE),
                        sd = ~sd(.x, na.rm = TRUE))), 
            .groups = 'drop') %>%
  mutate(across(everything(), ~replace_na(.x, 0)))  # Replace NA values with 0


# Aggregate the data by continent, calculating the mean for numeric variables
dendrogram_data_continent <- aggregated_fighter_data %>%
  group_by(Continent) %>%
  summarise(across(c(Height_mean, Weight_mean, Reach_mean), mean, na.rm = TRUE))

# View the aggregated data
print(dendrogram_data_continent)

# View the aggregated data
print(dendrogram_data_continent)

# Calculate the distance matrix based on the aggregated data
dist_matrix_continent <- dist(dendrogram_data_continent[, -1])  # Exclude the 'Continent' column for clustering

# Perform hierarchical clustering using the Ward method
hc_continent <- hclust(dist_matrix_continent, method = "ward.D2")

# Plot the dendrogram with continent labels
plot(hc_continent, labels = dendrogram_data_continent$Continent, main = "Dendrogram of Continents Based on Fighter Metrics", xlab = "", sub = "", cex = 0.7)

# Save the dendrogram as a PDF
pdf("dendrogram_ufc_continents.pdf", width = 10, height = 8)
plot(hc_continent, labels = dendrogram_data_continent$Continent, main = "Dendrogram of Continents Based on Fighter Metrics", xlab = "", sub = "", cex = 0.7)
dev.off()




# ------------
